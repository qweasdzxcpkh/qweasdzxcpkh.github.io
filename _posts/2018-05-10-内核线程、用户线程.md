---
layout:     post
title:      内核线程、用户线程
subtitle:   内核线程、用户线程
date:       2018-05-10
author:     carson
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - 线程
---

### 0：问题
线程是程序流执行调度的最小单位。之前一直在想，单进程双线程状态下，双核cpu在某一时刻下是否能够同时执行这两个线程。如果不能，那单进程多线程模式岂不是只能使用一个核的性能？
带着这个问题google，发现自己linux的进程管理、内存管理果然还是只知皮毛。。。

### 1：三种线程概念-内核线程、用户线程、（?）

根据内核是否对线程可感知，线程分为*内核线程*和*用户线程*。

#### 1.1：用户线程

用户线程的创建、销毁、管理由应用程序调用线程库实现，用户线程仅存在于用户空间中，创建和销毁用户线程都不需要利用系统调用实现，内核感知不到用户线程。


#### 1.2：内核线程

内核线程的建立和销毁，都是通过系统调用完成的。内核线程的管理、调度等工作都是由内核完成，应用程序不能参与。可以理解为：处理器的时间片轮转执行就是面向内核线程的。用户线程通过绑定内核线程才能获得时间片执行。


### 2：线程模型

1. 想象一下，如果只用单线程会怎样？
> 因为线程是cpu调度的最小单元，在单线程情况下，意味着在某一时刻线程只能运行在一个处理器上，不能充分利用多处理器框架的计算机
2. 如果用多进程+单线程呢？ 
> 多进程可以增加计算机的并发能力，但是创建子进程（fork）的消耗是很大的（为什么？），fork是一个系统调用。而且各个进程分别有独立的地址空间，进程间通信需要复杂的IPC技术（共享内存、队列、管道等技术），同样消耗系统资源，在需要频繁创建异步任务的情况下（比如异步IO）显然不合适。

因此在这些情况下，多线程就发挥作用了。多线程可以获得真正的并行（同时在多个处理器上执行不同的线程），同时由于共享进程的共享内存，线程间通信消耗小。当然，多线程因为共享进程的部分内存，在这部分内存上的全局数据需要保证一致性，即线程安全。这样就解决了在文章开头的问题。

不同的操作系统实现线程模型的方式不同，有的实现了*用户级线程模型*，有的实现了*内核级线程模型*。分类的标准主要是线程的调度者在核内还是在核外。前者更多考虑的是上下文切换开销，而后者更利于并发使用多处理器的资源。

#### 2.1：用户级线程模型
先上图：

![](https://github.com/qweasdzxcpkh/images/blob/master/ProcessAndThread/kthread0.png?raw=true)

用户级线程模型，更注重于上下文切换的开销。因为在这种线程模型下，用户线程的派生不需要内核参与，不用切换内核台/用户态。一个内核线程绑定一个用户进程，至于用户进程内哪个用户线程占用处理器，由库调度器分配。用户进程和内核线程的一对一关系使得处理器的时间片分配也是基于用户进程的，对于每个用户线程来说执行的时间相对减少了。

内核感知不到用户线程的存在。任意某一时刻，每个用户进程只能够有一个线程在运行。

但是，正因为内核感知不到用户线程，一旦执行中线程引起阻塞会导致整个用户进程阻塞。

#### 2.2：内核级线程模型

![](https://github.com/qweasdzxcpkh/images/blob/master/ProcessAndThread/kthread1.png?raw=true)

内核级线程模型下，每个用户线程绑定到一个内核线程上。无论是用户进程还是系统进程，它们的线程创建、调度、销毁都需要进行系统调用。同一用户进程下的多个线程由于绑定了不同的内核线程，所以同一用户进程下的多个线程在某一时刻下可以同时在执行，充分利用了多处理器的资源。
因为用户线程可能会很多，创建线程时需要考虑当前系统的线程数。
操作系统为每个线程都创建上下文，切换消耗比用户级线程模型稍大。

### 3：第三种线程模型：混合型线程模型

![](https://github.com/qweasdzxcpkh/images/blob/master/ProcessAndThread/kthread2.png?raw=true)

混合型线程模型结合了用户级线程模型和内核级线程模型的优点。
混合型线程模型赋予了程序猿一些控制权，可以控制线程库中的用户线程和内核线程的绑定关系，这样就牵涉到第三种线程概念：轻进程（LWP）

轻进程可以理解为内核线程但有一点不同，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状态下，一个用户线程将与一个轻进程绑定，这个用户线程由于处理器时间片是面向轻进程的，所以具有较高的响应速度。


#### 参考
* https://blog.csdn.net/gatieme/article/details/51892437
* https://blog.csdn.net/gatieme/article/details/51481863

