## 介绍
* **进程是操作系统资源(内存)动态调度的基本单元**
* 一个进程内有至少一个线程
* 线程是程序执行流(cpu调度)的最小单位
* 线程之间各自持有自己的线程 ID、当前指令的指针（PC）、寄存器集合以及栈

## 为什么需要线程安全
    线程需要“安全”主要是因为线程间共享了一些进程级资源（比如内存），而变量就是存储在内存中的，由于cpu时间片轮转的关系，线程在经过一次中断后，便无法确保共享内存内的变量是否被其他线程读取使用过，从而导致读取“脏数据”。

## 确保线程安全的方法
* 竞争与原子操作
* 同步与锁
* 可重入函数编程
* 阻止编译器过度优化
* 阻止cpu动态调度

#### 竞争与原子操作
> 从指令出发解决问题：

> > 线程中执行的一句代码，编译成汇编语言（内核可直接执行的代码）后可能不只一条指令，而指令集的执行是可以被系统中断的，因此当两条线程同时访问共享内存内的变量时，有可能造成操作冲突，得不到预期的结果（类似数据库的事务）。

> > 因此，可以利用linux系统提供的常用操作的原子指令，确保线程间切换也不会造成数据异常，确保线程的安全。但是一些复杂的场景，是不可能只利用这些原子指令就完成业务的。因此局限性比较大。

#### 同步与锁
> 既然从指令出发的解决办法有局限，那么从数据出发解决：

> > 对于共享内存内的变量，可以加上一个锁机制（又是数据库），当一条线程访问共享变量A，那么A上锁，其他线程便不能修改甚至访问这个变量A（其中的实现又有很多冲突处理办法）。

> > 锁有多种，排它锁、共享锁等等。详情google。

#### 可重入函数编程

> 从代码出发解决：

> > 如果一个函数，无论执行多少次，得到的结果都是唯一的，那么这个函数就是可重入函数。一个可重入的函数无论在多线程还是其他环境下都可以放心地使用。

> > ps：从代码出发解决线程安全的办法还有一个：协程。协程其实是一个单线程程序，cpu轮片怎么跳转线程也不会有其他线程与协程的共享变量产生访问冲突。协程的特点是利用代码进行指令执行的逻辑跳转，从而避免了任何线程切换或者进程切换的开销。不过编程难度大。架构上来说，协程一般结合多进程和时间驱动模型使用。多进程保留了协程不产生访问冲突的优势从而提高并罚，事件驱动则是重点在I/O操作的耗时，避免了协程执行因为I/O操作而阻塞

#### 阻止编译器过度优化

> 就算使用了*锁*机制，可能还是不能够保证线程安全，因此可以对代码进行过度优化以确保线程安全我暂时理解为应对过度优化手段的方法（没深入探究过，仅供参考）：

> * c中的对变量的volatile关键字

> * python中的cached_property库（实现了一个跨线程访问安全的装饰器）

> > 原理：

> > - 阻止编译器寄存器为了提高速度而将变量缓存在寄存器不写回内存

#### 阻止cpu动态调度

> ##### cpu动态调度可能会对互不依赖的两条*cpu指令*交换执行，比如：

> > `p = new People`

> 这句代码完成了三件事：

> 1. 为People类型对象分配内存

> 2. 在这片内存上执行People构造函数

> 3. 将该内存起始地址复制给p
    由于对p赋值操作和执行People构造函数初始化这两条指令互不依赖，就算不执行构造函数初始化，仍然可以执行第三步，因此，存在一种执行步骤：
    1、3、线程中断、2
    在线程中断时，其他线程判断p != NULL，然而p此时指向的只是一片未初始化的内存，对p的访问可能会造成程序崩溃

> 由于cpu动态调度是cpu的功能，高级程序语言并没有通用的解决办法解决这个问题，只能依赖具体cpu架构对代码进行调整。对于i386架构cpu，它提供了一条指令`mfence`，可以阻止这种cpu动态调度的换序执行

##### 题外话
    其实就像数据库的事务级别，除非完全*串行化*(serializable)，否则安全只是相对于并发量来说的。并发量越大越难保证数据库的数据安全和线程安全

